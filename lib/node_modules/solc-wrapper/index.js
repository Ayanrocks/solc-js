var translate = require('./translate.js')
var linker = require('./linker.js')

const assert = (bool, msg) => { if (!bool) throw new Error(msg) }

module.exports = wrapper

function wrapper (soljson) {
  var compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number'])
  var compileJSONMulti = null
  if ('_compileJSONMulti' in soljson) {
    compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number'])
  }
  var compileJSONCallback = null, compileStandard = null
  if (('_compileJSONCallback' in soljson) || ('_compileStandard' in soljson)) {
    function copyString (str, ptr) {
      var length = soljson.lengthBytesUTF8(str)
      var buffer = soljson._malloc(length + 1)
      soljson.stringToUTF8(str, buffer, length + 1)
      soljson.setValue(ptr, buffer, '*')
    }
    function wrapCallback (callback) {
      assert(typeof callback === 'function', 'Invalid callback specified.')
      return function (path, contents, error) {
        var result = callback(soljson.Pointer_stringify(path))
        if (typeof result.contents === 'string') copyString(result.contents, contents)
        if (typeof result.error === 'string') copyString(result.error, error)
      }
    }
    // This calls compile() with args || cb
    function runWithReadCallback (readCallback, compile, args) {
      if (readCallback === undefined) readCallback = path => ({ error: 'File import callback not supported' })
      var cb = soljson.Runtime.addFunction(wrapCallback(readCallback))
      var output
      try {
        args.push(cb)
        output = compile.apply(undefined, args)
      } catch (e) {
        soljson.Runtime.removeFunction(cb)
        throw e
      }
      soljson.Runtime.removeFunction(cb)
      return output
    }
    var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number'])
    compileJSONCallback = function (input, optimize, readCallback) {
      return runWithReadCallback(readCallback, compileInternal, [ input, optimize ])
    }
    if ('_compileStandard' in soljson) {
      var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number'])
      compileStandard = function (input, readCallback) {
        return runWithReadCallback(readCallback, compileStandardInternal, [ input ])
      }
    }
  }
  function compile (input, optimise, readCallback) {
    var result = ''
    if (readCallback !== undefined && compileJSONCallback !== null) {
      result = compileJSONCallback(JSON.stringify(input), optimise, readCallback)
    } else if (typeof input !== 'string' && compileJSONMulti !== null) {
      result = compileJSONMulti(JSON.stringify(input), optimise)
    } else {
      result = compileJSON(input, optimise)
    }
    return JSON.parse(result)
  }
  function compileStandardWrapper (input, readCallback) {
    // Expects a Standard JSON I/O but supports old compilers
    if (compileStandard !== null) return compileStandard(input, readCallback)
    function formatFatalError (message) {
      return JSON.stringify({
        errors: [{
          'type': 'SOLCError',
          'component': 'solcjs',
          'severity': 'error',
          'message': message,
          'formattedMessage': 'Error: ' + message,
        }]
      })
    }
    if (readCallback !== undefined && typeof readCallback !== 'function') {
      return formatFatalError('Invalid import callback supplied')
    }
    input = JSON.parse(input)
    if (input['language'] !== 'Solidity') {
      return formatFatalError('Only Solidity sources are supported')
    }
    if (input['sources'] == null) return formatFatalError('No input specified')
    if ((input['sources'].length > 1) && (compileJSONMulti === null)) { // Bail out early
      return formatFatalError('Multiple sources provided, but compiler only supports single input')
    }
    function isOptimizerEnabled (input) {
      return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled']
    }
    function translateSources (input) {
      var sources = {}
      for (var source in input['sources']) {
        if (input['sources'][source]['content'] !== null) {
          sources[source] = input['sources'][source]['content']
        } else return null // force failure
      }
      return sources
    }
    function librariesSupplied (input) {
      if (input['settings'] !== null) return input['settings']['libraries']
    }
    function translateOutput (output) {
      output = translate.translateJsonCompilerOutput(JSON.parse(output))
      if (output == null) return formatFatalError('Failed to process output')
      return JSON.stringify(output)
    }
    var sources = translateSources(input)
    if (sources === null || Object.keys(sources).length === 0) {
      return formatFatalError('Failed to process sources')
    }
    var libraries = librariesSupplied(input) // Try linking if libraries were supplied
    if (compileJSONCallback !== null) { // Try to wrap around old versions
      var sources = JSON.stringify({ sources })
      return translateOutput(compileJSONCallback(sources, isOptimizerEnabled(input), readCallback), libraries)
    }
    if (compileJSONMulti !== null) {
      var sources = JSON.stringify({ sources })
      return translateOutput(compileJSONMulti(sources, isOptimizerEnabled(input)), libraries)
    } // Try our luck with an ancient compiler
    return translateOutput(compileJSON(sources[Object.keys(sources)[0]], isOptimizerEnabled(input)), libraries)
  }
  var version = soljson.cwrap('version', 'string', [])
  function versionToSemver () { return translate.versionToSemver(version()) }
  function license () { /* return undefined */ }
  if ('_license' in soljson) license = soljson.cwrap('license', 'string', [])
  return {
    version: version,
    semver: versionToSemver,
    license: license,
    compile: compile,
    compileStandard: compileStandard,
    compileStandardWrapper: compileStandardWrapper,
    linkBytecode: linker.linkBytecode,
    supportsMulti: compileJSONMulti !== null,
    supportsImportCallback: compileJSONCallback !== null,
    supportsStandard: compileStandard !== null,
  }
}
