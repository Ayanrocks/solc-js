// //////////////////////////////////////////////////////////////////
// var Compiler = require('./src/compiler/compiler')
// var CompilerInput = require('./src/compiler/compiler-input')
// module.exports = { Compiler, CompilerInput }
// => Provides:
//
//     {
//         InternalCallTree: InternalCallTree,
//         SolidityProxy: SolidityProxy,
//         localDecoder: localDecoder,
//         stateDecoder: stateDecoder,
//         CodeAnalysis: CodeAnalysis
//     }
// //////////////////////////////////////////////////////////////////
const wrapper = require('./wrapper.js')
const format = require('./format.js')
// const solcABI = require('./helper/abi-patcher.js')
// const CompilerImport = require('./helper/handle-imports.js')

/******************************************************************************
  MODULE
******************************************************************************/
/*
  triggers
  - compilationFinished
  - compilerLoaded
  - compilationStarted
  - compilationDuration
*/
module.exports = compiler

function compiler (solc) {
  const _compiler = wrapper(solc)
  const api = {}

  // var zelf = instantiate()
  // var REMIX_SOLIDITY = new Compiler(_compiler, (url, cb) => zelf.importFileCb(url, cb))
  // console.log('REMIX_SOLIDITY', REMIX_SOLIDITY)

  Object.keys(_compiler).forEach(key => {
    if (key === 'compile') {
      // @TODO: allow to pass FILE_PATH instead of SOURCE_CODE
      // api.compile = function (files /* === main.js */, target) {
      //   console.log('files =', files)
      //   console.log('target =', target)
      //   console.error(`[on:compile:start] solc.compile(files, target)`)
      //   return REMIX_SOLIDITY.compile(files, target)
      // }
      api.compile = function (version, sourcecode = '', done) {
        // console.error(`[on:compile:start] solc.compile(sourcecode)`)
        var data = _compiler.compile(sourcecode, 1)
        if (!Object.keys(data.contracts).length) {
          debugger
          var R = /^(.*):(\d+):(\d+):(.*):/
          var err = data.errors[0]
          if (typeof err === 'string') {
            var type = R.exec(err)
            err = {
              component: 'general',
              formattedMessage: err,
              message: err,
              type: type ? type[4].trim() : 'Error'
            }
          }
          return done(err)
        }
        var output = format(version, data)
        done(null, output)
      }
    }
    else if (typeof _compiler[key] === 'function') api[key] = function (...args) {
      console.error(`compiler.${key}(...args)`, args)
      return _compiler[key].apply(_compiler, args)
    }
    else Object.defineProperty(api, key, {
      get () {
        var currentValue = _compiler[key]
        console.error(`compiler.${key} === `, currentValue)
        return currentValue
      },
      set (newValue) {
        console.error(`compiler.${key} = `, newValue)
        return _compiler[key] = newValue
      },
      enumerable: true,
      configurable: true
    })
  })
  return api
}
